# 🧠 Core Architectural Skills

This section covers the fundamental skills every senior software architect must master. These are the technical foundations that enable you to design, build, and evolve large-scale software systems.

## 📁 Contents

### [🏗️ System Design](./system-design/README.md)
Deep dive into designing scalable, resilient distributed systems
- [Large-Scale Distributed Systems](./system-design/distributed-systems.md)
- [Scalability Patterns](./system-design/scalability.md)
- [Fault Tolerance & Resilience](./system-design/fault-tolerance.md)
- [CAP Theorem & Trade-offs](./system-design/cap-theorem.md)
- [API Design Excellence](./system-design/api-design.md)
- [Message Queues & Event Systems](./system-design/messaging.md)
- [System Boundaries & Domain Decomposition](./system-design/system-boundaries.md)

### [🏛️ Architecture Patterns](./architecture-patterns/README.md)
Comprehensive coverage of architectural styles and patterns
- [Monolith vs. Microservices vs. Modular Monolith](./architecture-patterns/architectural-styles.md)
- [Event-Driven Architecture](./architecture-patterns/event-driven.md)
- [Serverless Architecture](./architecture-patterns/serverless.md)
- [Clean Architecture & Layered Patterns](./architecture-patterns/clean-architecture.md)
- [Domain-Driven Design (DDD)](./architecture-patterns/domain-driven-design.md)
- [Event Sourcing & CQRS](./architecture-patterns/event-sourcing-cqrs.md)

## 🎯 Learning Objectives

After mastering this section, you should be able to:

1. **Design Large-Scale Systems**
   - Architect systems that can handle millions of users
   - Choose appropriate scalability patterns for different scenarios
   - Design for fault tolerance and high availability
   - Make informed trade-offs using CAP theorem principles

2. **Apply Architecture Patterns**
   - Select the right architectural style for your use case
   - Implement event-driven architectures effectively
   - Apply clean architecture principles consistently
   - Use Domain-Driven Design for complex business domains

3. **Make Architectural Decisions**
   - Evaluate trade-offs between different approaches
   - Document architectural decisions with clear rationale
   - Communicate complex technical concepts to stakeholders
   - Evolve architectures over time without breaking existing systems

## 🚀 Getting Started

1. **Start with Fundamentals**: Begin with [Distributed Systems](./system-design/distributed-systems.md) to understand the basics
2. **Understand Trade-offs**: Study [CAP Theorem](./system-design/cap-theorem.md) to learn about fundamental limitations
3. **Choose Patterns**: Explore [Architectural Styles](./architecture-patterns/architectural-styles.md) to understand when to use each approach
4. **Practice Design**: Work through real-world scenarios and design exercises
5. **Apply Learning**: Implement these concepts in your current projects

## 📚 Recommended Prerequisites

- Solid understanding of software engineering principles
- Experience with at least one programming language and framework
- Basic knowledge of databases and networking
- Familiarity with cloud platforms (AWS, Azure, or GCP)

---

*Navigate to specific topics using the links above, or return to the [main learning path](../README.md).*